<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Word Builder</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f3f4f6;
            display: flex;
            justify-content: center;
            align-items: flex-start;
            min-height: 100vh;
            padding-top: 2rem;
            padding-bottom: 2rem;
            margin: 0;
        }
        .tile {
            display: inline-block;
            /* Optimized for iPad/Touch */
            padding: 0.75rem 1rem; /* Increased padding for larger touch target */
            margin: 0.25rem;       /* Slightly increased margin */
            font-size: 1rem;      /* Increased font size for readability */

            border-radius: 0.375rem;
            border-width: 1px;
            box-shadow: 0 1px 2px 0 rgba(0, 0, 0, 0.05);
            font-weight: 500;
            cursor: grab;
            transition: transform 0.15s ease-in-out, box-shadow 0.15s ease-in-out;
            user-select: none;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            touch-action: none;
            position: relative;
        }
        .tile:hover {
            transform: scale(1.08);
        }
        .tile.dragging {
            opacity: 0.5;
            box-shadow: 0 10px 15px -3px rgba(0,0,0,0.2), 0 4px 6px -2px rgba(0,4,0,0.1);
            cursor: grabbing;
            z-index: 1000;
        }
        .drop-zone {
            min-height: 120px;
            padding: 0.75rem;
            border-width: 2px;
            border-style: dashed;
            border-color: #d1d5db;
            border-radius: 0.5rem;
            background-color: #ffffff;
            gap: 0.125rem;
            display: flex;
            flex-wrap: wrap;
            align-items: center;
            position: relative;
        }
        .drop-zone.drag-over {
            background-color: #eff6ff;
            border-color: #60a5fa;
        }
        .source-container {
            min-height: 120px; /* Ensure sufficient height for drop */
            padding: 0.75rem;
            border-width: 2px;
            border-style: dashed; /* Changed to dashed for consistency */
            border-color: #d1d5db; /* Default border color */
            border-radius: 0.5rem;
            background-color: #ffffff;
            gap: 0.125rem;
            display: flex;
            flex-wrap: wrap;
            align-items: flex-start; /* Align items to top for better flow */
            align-content: flex-start; /* Ensure content starts from top */
            position: relative;
        }
        .source-container.drag-over {
            background-color: #dbeafe;
            border-color: #3b82f6;
        }
        .card {
            border-radius: 0.75rem;
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
        }
        .card-content {
            padding: 1.25rem;
        }
        .placeholder-text {
            color: #9ca3af;
            font-style: italic;
            width: 100%;
            text-align: center;
            font-size: 0.875rem;
        }
        .insertion-indicator {
            position: absolute;
            width: 2px;
            background-color: #3b82f6;
            height: 80%;
            top: 10%;
            pointer-events: none;
            animation: pulse 1s infinite alternate;
        }

        @keyframes pulse {
            from { opacity: 0.5; }
            to { opacity: 1; }
        }
    </style>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
</head>
<body>
    <div class="max-w-4xl w-full mx-auto py-8 px-4">
        <h1 class="text-4xl font-bold text-center mb-8 text-gray-700">Word Builder</h1>

        <div class="grid grid-cols-1 md:grid-cols-3 gap-6 mb-10">
            <div class="card bg-white">
                <div class="card-content">
                    <h2 class="text-2xl font-semibold mb-4 text-blue-600">Prefixes</h2>
                    <div id="prefixes-container" class="flex flex-wrap gap-0.5 source-container">
                        </div>
                </div>
            </div>
            <div class="card bg-white">
                <div class="card-content">
                    <h2 class="text-2xl font-semibold mb-4 text-green-600">Root Words & Morphemes</h2>
                    <div id="roots-container" class="flex flex-wrap gap-0.5 source-container">
                        </div>
                </div>
            </div>
            <div class="card bg-white">
                <div class="card-content">
                    <h2 class="text-2xl font-semibold mb-4 text-pink-600">Suffixes</h2>
                    <div id="suffixes-container" class="flex flex-wrap gap-0.5 source-container">
                        </div>
                </div>
            </div>
        </div>

        <div class="card bg-gray-50">
            <div class="card-content">
                <h2 class="text-2xl font-semibold mb-4 text-gray-700">Combine Tiles Here</h2>
                <div id="combination-area" class="drop-zone">
                    <span class="placeholder-text">Drag tiles from above to build your word!</span>
                </div>
                <div class="mt-6 flex flex-col sm:flex-row items-center justify-between gap-4">
                    <div class="text-2xl font-bold text-gray-800">
                        Combined Word: <span id="combined-word-display" class="text-indigo-600"></span>
                    </div>
                    <div class="flex flex-col sm:flex-row gap-4">
                        <button id="share-link-button" class="bg-purple-500 hover:bg-purple-600 text-white font-bold py-2 px-4 rounded-lg shadow-md transition-colors duration-200">
                            Copy Share Link
                        </button>
                        <button id="reset-button" class="bg-red-500 hover:bg-red-600 text-white font-bold py-2 px-4 rounded-lg shadow-md transition-colors duration-200">
                            Reset All
                        </button>
                    </div>
                </div>
            </div>
        </div>

        <div id="upload-sections-container" class="grid grid-cols-1 md:grid-cols-3 gap-6 mt-8">
            <div class="card bg-white">
                <div class="card-content">
                    <h2 class="text-2xl font-semibold mb-4 text-blue-600">Upload Prefixes</h2>
                    <p class="text-gray-600 mb-4 text-sm">
                        Each prefix on a new line. Replaces existing.
                    </p>
                    <div class="flex flex-col sm:flex-row items-center gap-4">
                        <input type="file" id="prefixesFileUpload" accept=".txt"
                               class="block w-full text-sm text-gray-500
                                    file:mr-4 file:py-2 file:px-4
                                    file:rounded-full file:border-0
                                    file:text-sm file:font-semibold
                                    file:bg-blue-50 file:text-blue-700
                                    hover:file:bg-blue-100"/>
                        <button id="loadPrefixesButton" class="bg-blue-500 hover:bg-blue-600 text-white font-bold py-2 px-4 rounded-lg shadow-md transition-colors duration-200 w-full sm:w-auto">
                            Load Prefixes
                        </button>
                    </div>
                </div>
            </div>

            <div class="card bg-white">
                <div class="card-content">
                    <h2 class="text-2xl font-semibold mb-4 text-green-600">Upload Root Words</h2>
                    <p class="text-gray-600 mb-4 text-sm">
                        Each root on a new line (e.g., `vis` or `vis:vid`). Replaces existing.
                    </p>
                    <div class="flex flex-col sm:flex-row items-center gap-4">
                        <input type="file" id="rootsFileUpload" accept=".txt"
                               class="block w-full text-sm text-gray-500
                                    file:mr-4 file:py-2 file:px-4
                                    file:rounded-full file:border-0
                                    file:text-sm file:font-semibold
                                    file:bg-green-50 file:text-green-700
                                    hover:file:bg-green-100"/>
                        <button id="loadRootsButton" class="bg-green-500 hover:bg-green-600 text-white font-bold py-2 px-4 rounded-lg shadow-md transition-colors duration-200 w-full sm:w-auto">
                            Load Roots
                        </button>
                    </div>
                </div>
            </div>

            <div class="card bg-white">
                <div class="card-content">
                    <h2 class="text-2xl font-semibold mb-4 text-pink-600">Upload Suffixes</h2>
                    <p class="text-gray-600 mb-4 text-sm">
                        Each suffix on a new line. Replaces existing.
                    </p>
                    <div class="flex flex-col sm:flex-row items-center gap-4">
                        <input type="file" id="suffixesFileUpload" accept=".txt"
                               class="block w-full text-sm text-gray-500
                                    file:mr-4 file:py-2 file:px-4
                                    file:rounded-full file:border-0
                                    file:text-sm file:font-semibold
                                    file:bg-pink-50 file:text-pink-700
                                    hover:file:bg-pink-100"/>
                        <button id="loadSuffixesButton" class="bg-pink-500 hover:bg-pink-600 text-white font-bold py-2 px-4 rounded-lg shadow-md transition-colors duration-200 w-full sm:w-auto">
                            Load Suffixes
                        </button>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            console.log("DOM Content Loaded. Script starting.");

            // --- DATA & CONSTANTS ---
            const PREFIX_COLOR = "bg-blue-200 border-blue-400";
            const ROOT_COLOR = "bg-green-200 border-green-400";
            const SUFFIX_COLOR = "bg-pink-200 border-pink-400";

            const initialAvailableData = {
                prefixes: ["un", "re", "pre", "dis", "mis", "de", "anti", "co"],
                roots: parseRootsData(["port", "vis:vid", "graph", "rupt", "dict", "aud", "bene", "mal", "create", "fuse"]),
                suffixes: ["able", "ment", "tion", "er", "est", "fy", "ize", "ous", "ion"]
            };

            let availableData = {};
            let combinedTilesData = [];
            let draggedTile = null;
            let touchDraggedTile = null;
            let globalTileIdCounter = 0;

            // --- DOM Element References ---
            const prefixesContainer = document.getElementById('prefixes-container');
            const rootsContainer = document.getElementById('roots-container');
            const suffixesContainer = document.getElementById('suffixes-container');
            let combinationArea = document.getElementById('combination-area');

            if (!combinationArea) {
                console.error("FATAL ERROR: #combination-area element not found. Drag-and-drop and word combining will not work.");
                return;
            }

            const combinedWordDisplay = document.getElementById('combined-word-display');
            const resetButton = document.getElementById('reset-button');
            const shareLinkButton = document.getElementById('share-link-button');

            const uploadSectionsContainer = document.getElementById('upload-sections-container');
            const prefixesFileUpload = document.getElementById('prefixesFileUpload');
            const loadPrefixesButton = document.getElementById('loadPrefixesButton');
            const rootsFileUpload = document.getElementById('rootsFileUpload');
            const loadRootsButton = document.getElementById('loadRootsButton');
            const suffixesFileUpload = document.getElementById('suffixesFileUpload');
            const loadSuffixesButton = document.getElementById('loadSuffixesButton');

            let insertionIndicator = null;


            // --- HELPER FUNCTIONS ---
            function parseRootsData(arr) {
                let out = [];
                arr.forEach(item => {
                    item.split(/[:,]/).forEach(word => {
                        const clean = word.trim();
                        if (clean && !out.includes(clean)) out.push(clean);
                    });
                });
                return out.sort();
            }

            function createTileElement(text, type, colorClass, id = null) {
                const tile = document.createElement('div');
                tile.classList.add('tile');
                tile.textContent = text;
                tile.dataset.text = text;
                tile.dataset.type = type;
                tile.dataset.color = colorClass;
                tile.id = id || `${type}-tile-${globalTileIdCounter++}`;

                const colors = colorClass.split(' ');
                colors.forEach(c => tile.classList.add(c));

                tile.draggable = true;
                tile.addEventListener('dragstart', handleDragStart);
                tile.addEventListener('dragend', handleDragEnd);
                tile.addEventListener('touchstart', handleTouchStart, { passive: false });

                return tile;
            }

            function createOrUpdateInsertionIndicator() {
                if (!combinationArea) {
                    console.error("createOrUpdateInsertionIndicator: combinationArea is null. Cannot create indicator.");
                    return null;
                }

                let existingIndicator = combinationArea.querySelector('.insertion-indicator');
                if (existingIndicator) {
                    insertionIndicator = existingIndicator;
                } else {
                    insertionIndicator = document.createElement('div');
                    insertionIndicator.classList.add('insertion-indicator');
                    combinationArea.appendChild(insertionIndicator);
                }
                insertionIndicator.style.display = 'none';
                return insertionIndicator;
            }


            function showInsertionIndicator(xCoord, yCoord) {
                const currentCombinationArea = document.getElementById('combination-area');
                const currentInsertionIndicator = createOrUpdateInsertionIndicator();
                const currentPlaceholderText = currentCombinationArea ? currentCombinationArea.querySelector('.placeholder-text') : null;


                if (!currentInsertionIndicator || (!draggedTile && !touchDraggedTile) || !currentCombinationArea) {
                    return;
                }

                const containerRect = currentCombinationArea.getBoundingClientRect();
                const containerX = containerRect.left;

                const afterElement = getDragAfterElement(currentCombinationArea, xCoord);

                let indicatorLeft;
                if (afterElement === null) {
                    const lastTile = currentCombinationArea.lastElementChild;
                    if (lastTile && lastTile !== currentPlaceholderText && lastTile !== currentInsertionIndicator) {
                        const lastTileRect = lastTile.getBoundingClientRect();
                        indicatorLeft = lastTileRect.right - containerX + 2;
                    } else {
                        indicatorLeft = 5;
                    }
                } else {
                    const afterRect = afterElement.getBoundingClientRect();
                    indicatorLeft = afterRect.left - containerX - 2;
                }

                indicatorLeft = Math.max(0, Math.min(indicatorLeft, containerRect.width - currentInsertionIndicator.offsetWidth));

                currentInsertionIndicator.style.left = `${indicatorLeft}px`;
                currentInsertionIndicator.style.display = 'block';
            }

            function hideInsertionIndicator() {
                const currentInsertionIndicator = document.getElementById('combination-area')?.querySelector('.insertion-indicator');
                if (currentInsertionIndicator) {
                    currentInsertionIndicator.style.display = 'none';
                }
            }


            // --- RENDERING FUNCTIONS ---
            function renderAvailableTiles() {
                // Helper to manage placeholders in source containers
                const manageSourcePlaceholder = (container, hasTiles) => {
                    let placeholder = container.querySelector('.source-placeholder');
                    if (!placeholder) {
                        placeholder = document.createElement('div');
                        placeholder.classList.add('source-placeholder');
                        // Set specific text based on container
                        if (container.id === 'prefixes-container') placeholder.textContent = 'No prefixes. Drop here to add.';
                        else if (container.id === 'roots-container') placeholder.textContent = 'No roots. Drop here to add.';
                        else if (container.id === 'suffixes-container') placeholder.textContent = 'No suffixes. Drop here to add.';
                        container.appendChild(placeholder);
                    }
                    placeholder.style.display = hasTiles ? 'none' : 'block';
                };

                [prefixesContainer, rootsContainer, suffixesContainer].forEach(container => {
                    // Remove only actual tiles
                    Array.from(container.children).filter(child => child.classList.contains('tile')).forEach(tile => container.removeChild(tile));
                });

                // Render prefixes
                if (availableData.prefixes.length === 0) {
                    manageSourcePlaceholder(prefixesContainer, false);
                } else {
                    availableData.prefixes.forEach(text => {
                        const tile = createTileElement(text, 'prefixes', PREFIX_COLOR);
                        prefixesContainer.appendChild(tile);
                    });
                    manageSourcePlaceholder(prefixesContainer, true);
                }

                // Render roots
                if (availableData.roots.length === 0) {
                    manageSourcePlaceholder(rootsContainer, false);
                } else {
                    availableData.roots.forEach(text => {
                        const tile = createTileElement(text, 'roots', ROOT_COLOR);
                        rootsContainer.appendChild(tile);
                    });
                    manageSourcePlaceholder(rootsContainer, true);
                }

                // Render suffixes
                if (availableData.suffixes.length === 0) {
                    manageSourcePlaceholder(suffixesContainer, false);
                } else {
                    availableData.suffixes.forEach(text => {
                        const tile = createTileElement(text, 'suffixes', SUFFIX_COLOR);
                        suffixesContainer.appendChild(tile);
                    });
                    manageSourcePlaceholder(suffixesContainer, true);
                }
            }


            function renderCombinedTiles() {
                // Remove only the draggable tiles, preserve placeholder and indicator
                const tilesInCombinationArea = Array.from(combinationArea.children).filter(
                    child => child.classList.contains('tile')
                );
                tilesInCombinationArea.forEach(tile => combinationArea.removeChild(tile));
                
                let currentPlaceholderText = combinationArea.querySelector('.placeholder-text');
                if (!currentPlaceholderText) {
                    currentPlaceholderText = document.createElement('span');
                    currentPlaceholderText.classList.add('placeholder-text');
                    currentPlaceholderText.textContent = 'Drag tiles from above to build your word!';
                    combinationArea.appendChild(currentPlaceholderText);
                }
                createOrUpdateInsertionIndicator();

                if (combinedTilesData.length === 0) {
                    currentPlaceholderText.style.display = 'block';
                } else {
                    currentPlaceholderText.style.display = 'none';
                    combinedTilesData.forEach(data => {
                        const tile = createTileElement(data.text, data.type, data.color, data.id);
                        if (currentPlaceholderText && currentPlaceholderText.style.display === 'block') {
                            combinationArea.insertBefore(tile, currentPlaceholderText);
                        } else if (insertionIndicator && insertionIndicator.style.display === 'block') {
                            combinationArea.insertBefore(tile, insertionIndicator);
                        } else {
                            combinationArea.appendChild(tile);
                        }
                    });
                }
                updateCombinedWordDisplay();
            }

            function updateCombinedWordDisplay() {
                let correctedWord = "";

                for (let i = 0; i < combinedTilesData.length; i++) {
                    let part = combinedTilesData[i].text;
                    let type = combinedTilesData[i].type;

                    if (i < combinedTilesData.length - 1) {
                        let nextPart = combinedTilesData[i + 1].text;
                        let nextType = combinedTilesData[i + 1].type;

                        if (type === 'roots' && nextType === 'suffixes' &&
                            part.endsWith('e') && "aeiou".includes(nextPart.charAt(0).toLowerCase())) {
                            correctedWord += part.slice(0, -1);
                        }
                        else {
                            correctedWord += part;
                        }
                    } else {
                        correctedWord += part;
                    }
                }

                combinedWordDisplay.textContent = correctedWord;
            }

            // --- DRAG AND DROP LOGIC (Desktop) ---
            function handleDragStart(e) {
                draggedTile = e.target;
                e.dataTransfer.setData('text/plain', draggedTile.id);
                e.dataTransfer.effectAllowed = 'move';
                setTimeout(() => {
                    draggedTile.classList.add('dragging');
                }, 0);
            }

            function handleDragEnd(e) {
                if (draggedTile) {
                    draggedTile.classList.remove('dragging');
                    draggedTile = null;
                }
                hideInsertionIndicator();
                // Clear drag-over from all containers
                document.querySelectorAll('.source-container, .drop-zone').forEach(container => {
                    container.classList.remove('drag-over');
                });
            }

            // Global dragover handler on body
            function handleBodyDragOver(e) {
                e.preventDefault(); // Crucial to allow dropping
                e.dataTransfer.dropEffect = 'move';

                // Find the actual element under the cursor
                let targetElement = document.elementFromPoint(e.clientX, e.clientY);
                let currentDropZone = null;

                // Traverse up the DOM to find a valid drop zone
                while (targetElement && targetElement !== document.body) {
                    if (targetElement.classList.contains('drop-zone') || targetElement.classList.contains('source-container')) {
                        currentDropZone = targetElement;
                        break;
                    }
                    targetElement = targetElement.parentElement;
                }

                // Remove drag-over from all containers first
                document.querySelectorAll('.source-container, .drop-zone').forEach(container => {
                    container.classList.remove('drag-over');
                });

                // Apply drag-over to the identified drop zone
                if (currentDropZone) {
                    currentDropZone.classList.add('drag-over');
                    if (currentDropZone === combinationArea) {
                        showInsertionIndicator(e.clientX, e.clientY);
                    } else {
                        hideInsertionIndicator();
                    }
                } else {
                    hideInsertionIndicator();
                }
            }

            // Global drop handler on body
            function handleBodyDrop(e) {
                e.preventDefault();
                const droppedTileId = e.dataTransfer.getData('text/plain');
                const droppedTileElement = document.getElementById(droppedTileId);

                if (!droppedTileElement) return;

                // Find the actual element under the cursor at the time of drop
                let targetElement = document.elementFromPoint(e.clientX, e.clientY);
                let targetContainer = null;

                // Traverse up the DOM to find a valid drop zone
                while (targetElement && targetElement !== document.body) {
                    if (targetElement.classList.contains('drop-zone') || targetElement.classList.contains('source-container')) {
                        targetContainer = targetElement;
                        break;
                    }
                    targetElement = targetElement.parentElement;
                }

                // Clear drag-over and hide indicator
                document.querySelectorAll('.source-container, .drop-zone').forEach(container => {
                    container.classList.remove('drag-over');
                });
                hideInsertionIndicator();

                const tileData = {
                    id: droppedTileElement.id,
                    text: droppedTileElement.dataset.text,
                    type: droppedTileElement.dataset.type,
                    color: droppedTileElement.dataset.color
                };

                const currentCombinationArea = document.getElementById('combination-area');

                if (targetContainer) {
                    if (currentCombinationArea && targetContainer === currentCombinationArea) {
                        // Logic for dropping into combination area
                        const originalContainer = droppedTileElement.parentElement;
                        if (originalContainer !== currentCombinationArea) {
                            const originalType = originalContainer.id.replace('-container', '');
                            availableData[originalType] = availableData[originalType].filter(item => item !== tileData.text);
                        } else {
                            combinedTilesData = combinedTilesData.filter(tile => tile.id !== tileData.id);
                        }

                        const afterElement = getDragAfterElement(currentCombinationArea, e.clientX);
                        if (afterElement === null) {
                            combinedTilesData.push(tileData);
                        } else {
                            const index = combinedTilesData.findIndex(tile => tile.id === afterElement.id);
                            if (index !== -1) {
                                combinedTilesData.splice(index, 0, tileData);
                            } else {
                                combinedTilesData.push(tileData);
                            }
                        }
                    }
                    else if (targetContainer.classList.contains('source-container')) {
                        // Logic for dropping into source containers
                        const targetType = targetContainer.id.replace('-container', '');

                        // Remove from combinedTilesData if it was there
                        combinedTilesData = combinedTilesData.filter(tile => tile.id !== tileData.id);

                        // Add to the target source container's availableData if not already present
                        if (!availableData[targetType].includes(tileData.text)) {
                            availableData[targetType].push(tileData.text);
                            availableData[targetType].sort();
                        }
                    }
                }

                renderAvailableTiles();
                renderCombinedTiles();
            }


            function getDragAfterElement(container, x) {
                if (!container) return null;

                const currentPlaceholderText = container.querySelector('.placeholder-text');
                const currentInsertionIndicator = container.querySelector('.insertion-indicator');

                const draggableElements = [...container.querySelectorAll('.tile:not(.dragging)')].filter(
                    element => element !== currentPlaceholderText && element !== currentInsertionIndicator
                );

                return draggableElements.reduce((closest, child) => {
                    const box = child.getBoundingClientRect();
                    const offset = x - box.left - (box.width / 2);

                    if (offset < 0 && offset > closest.offset) {
                        return { offset: offset, element: child };
                    } else {
                        return closest;
                    }
                }, { offset: Number.NEGATIVE_INFINITY, element: null }).element;
            }

            // --- TOUCH DRAG AND DROP LOGIC (Mobile) ---
            let initialTouchX, initialTouchY;

            function handleTouchStart(e) {
                if (e.touches.length !== 1) return;

                touchDraggedTile = e.target;
                if (!touchDraggedTile.classList.contains('tile')) {
                    touchDraggedTile = touchDraggedTile.closest('.tile');
                }
                if (!touchDraggedTile) return;

                e.preventDefault();

                touchDraggedTile.classList.add('dragging');

                initialTouchX = e.touches[0].clientX;
                initialTouchY = e.touches[0].clientY;

                touchDraggedTile.style.position = 'fixed';
                touchDraggedTile.style.zIndex = '1000';
                touchDraggedTile.style.left = `${initialTouchX - touchDraggedTile.offsetWidth / 2}px`;
                touchDraggedTile.style.top = `${initialTouchY - touchDraggedTile.offsetHeight / 2}px`;

                document.addEventListener('touchmove', handleTouchMove, { passive: false });
                document.addEventListener('touchend', handleTouchEnd);
            }

            function handleTouchMove(e) {
                if (!touchDraggedTile) return;
                e.preventDefault();

                const clientX = e.touches[0].clientX;
                const clientY = e.touches[0].clientY;

                touchDraggedTile.style.left = `${clientX - touchDraggedTile.offsetWidth / 2}px`;
                touchDraggedTile.style.top = `${clientY - touchDraggedTile.offsetHeight / 2}px`;

                // Temporarily hide the dragged tile to find the element underneath
                touchDraggedTile.style.display = 'none';
                const elementUnderTouch = document.elementFromPoint(clientX, clientY);
                touchDraggedTile.style.display = ''; // Show it again

                // Remove drag-over from all containers first
                document.querySelectorAll('.source-container, .drop-zone').forEach(container => {
                    container.classList.remove('drag-over');
                });

                let currentDropZone = null;
                // Traverse up the DOM to find a valid drop zone
                let targetElement = elementUnderTouch;
                while (targetElement && targetElement !== document.body) {
                    if (targetElement.classList.contains('drop-zone') || targetElement.classList.contains('source-container')) {
                        currentDropZone = targetElement;
                        break;
                    }
                    targetElement = targetElement.parentElement;
                }

                const currentCombinationArea = document.getElementById('combination-area');

                if (currentDropZone) {
                    currentDropZone.classList.add('drag-over');
                    if (currentCombinationArea && currentDropZone === currentCombinationArea) {
                        showInsertionIndicator(clientX, clientY);
                    } else {
                        hideInsertionIndicator();
                    }
                } else {
                    hideInsertionIndicator();
                }
            }

            function handleTouchEnd(e) {
                if (!touchDraggedTile) return;

                document.removeEventListener('touchmove', handleTouchMove);
                document.removeEventListener('touchend', handleTouchEnd);

                const clientX = e.changedTouches[0].clientX;
                const clientY = e.changedTouches[0].clientY;

                // Temporarily hide the dragged tile to find the element underneath
                touchDraggedTile.style.display = 'none';
                const elementUnderTouch = document.elementFromPoint(clientX, clientY);
                touchDraggedTile.style.display = ''; // Show it again

                let targetContainer = null;
                // Traverse up the DOM to find a valid drop zone
                let targetElement = elementUnderTouch;
                while (targetElement && targetElement !== document.body) {
                    if (targetElement.classList.contains('drop-zone') || targetElement.classList.contains('source-container')) {
                        targetContainer = targetElement;
                        break;
                    }
                    targetElement = targetElement.parentElement;
                }

                touchDraggedTile.style.position = '';
                touchDraggedTile.style.zIndex = '';
                touchDraggedTile.style.left = '';
                touchDraggedTile.style.top = '';
                touchDraggedTile.classList.remove('dragging');

                hideInsertionIndicator();
                document.querySelectorAll('.source-container, .drop-zone').forEach(container => {
                    container.classList.remove('drag-over');
                });

                const currentCombinationArea = document.getElementById('combination-area');

                if (targetContainer) {
                    const originalContainer = touchDraggedTile.parentElement;
                    const tileData = {
                        id: touchDraggedTile.id,
                        text: touchDraggedTile.dataset.text,
                        type: touchDraggedTile.dataset.type,
                        color: touchDraggedTile.dataset.color
                    };

                    if (currentCombinationArea && targetContainer === currentCombinationArea) {
                        if (originalContainer !== currentCombinationArea) {
                            const originalType = originalContainer.id.replace('-container', '');
                            availableData[originalType] = availableData[originalType].filter(item => item !== tileData.text);
                        } else {
                            combinedTilesData = combinedTilesData.filter(tile => tile.id !== tileData.id);
                        }

                        const afterElement = getDragAfterElement(currentCombinationArea, clientX);
                        if (afterElement === null) {
                            combinedTilesData.push(tileData);
                        } else {
                            const index = combinedTilesData.findIndex(tile => tile.id === afterElement.id);
                            if (index !== -1) {
                                combinedTilesData.splice(index, 0, tileData);
                            } else {
                                combinedTilesData.push(tileData);
                            }
                        }
                    }
                    else if (targetContainer.classList.contains('source-container')) {
                        const targetType = targetContainer.id.replace('-container', '');

                        combinedTilesData = combinedTilesData.filter(tile => tile.id !== tileData.id);

                        if (!availableData[targetType].includes(tileData.text)) {
                            availableData[targetType].push(tileData.text);
                            availableData[targetType].sort();
                        }
                    }
                }

                touchDraggedTile = null;

                renderAvailableTiles();
                renderCombinedTiles();
            }


            // --- FILE UPLOAD LOGIC ---
            function processFileUpload(fileInput, category) {
                console.log(`Attempting to process file for ${category}.`);
                const file = fileInput.files[0];

                if (!file) {
                    alert(`Please select a .txt file for ${category} using the 'Choose File' button, then click 'Load'.`);
                    console.warn(`No file object found for ${category} when 'Load' was clicked.`);
                    return;
                }

                console.log(`File selected: ${file.name} for ${category}. Reading...`);
                const reader = new FileReader();

                reader.onload = function(event) {
                    const fileContent = event.target.result;
                    const newWords = fileContent.split('\n')
                                            .map(word => word.trim())
                                            .filter(word => word.length > 0);

                    if (category === 'roots') {
                        availableData[category] = parseRootsData(newWords);
                    } else {
                        availableData[category] = newWords.sort();
                    }

                    combinedTilesData = [];
                    globalTileIdCounter = 0;
                    renderAvailableTiles();
                    renderCombinedTiles();
                    alert(`Successfully loaded ${newWords.length} new ${category}!`);
                    fileInput.value = '';
                    console.log(`Successfully loaded ${newWords.length} words for ${category}.`);
                };

                reader.onerror = function() {
                    console.error(`Error reading ${category} file:`, reader.error);
                    alert(`Could not read the ${category} file. Please try again.`);
                };

                reader.readAsText(file);
            }


            // --- EVENT LISTENERS ---
            // Global dragover handler on body
            document.body.addEventListener('dragover', handleBodyDragOver);
            document.body.addEventListener('drop', handleBodyDrop);

            resetButton.addEventListener('click', () => {
                // Preserve availableData, only clear combined tiles
                combinedTilesData = [];
                globalTileIdCounter = 0; // Reset ID counter for new tiles
                renderAvailableTiles(); // Re-render source containers to ensure placeholders are correct
                renderCombinedTiles(); // Re-render combined area
                console.log("Combined word cleared. Lists preserved.");
            });

            if (shareLinkButton) {
                shareLinkButton.addEventListener('click', () => {
                    const encodedData = btoa(JSON.stringify(availableData));
                    const currentUrl = window.location.origin + window.location.pathname;
                    const shareUrl = `${currentUrl}?shared=true&data=${encodedData}`;

                    const tempInput = document.createElement('textarea');
                    tempInput.value = shareUrl;
                    document.body.appendChild(tempInput);
                    tempInput.select();
                    try {
                        const successful = document.execCommand('copy');
                        if (successful) {
                            alert("Share link copied to clipboard:\n" + shareUrl);
                            console.log("Share link copied:", shareUrl);
                        } else {
                            alert("Could not copy link to clipboard. Please copy it manually:\n" + shareUrl);
                            console.warn("Failed to copy share link using execCommand.");
                        }
                    } catch (err) {
                        console.error('Failed to copy share link: ', err);
                        alert("Could not copy link to clipboard. Please copy it manually:\n" + shareUrl);
                    } finally {
                        document.body.removeChild(tempInput);
                    }
                });
            }


            loadPrefixesButton.addEventListener('click', () => {
                console.log("Load Prefixes button clicked.");
                processFileUpload(prefixesFileUpload, 'prefixes');
            });
            loadRootsButton.addEventListener('click', () => {
                console.log("Load Roots button clicked.");
                processFileUpload(rootsFileUpload, 'roots');
            });
            loadSuffixesButton.addEventListener('click', () => {
                console.log("Load Suffixes button clicked.");
                processFileUpload(suffixesFileUpload, 'suffixes');
            });


            // --- INITIALIZATION ---
            const urlParams = new URLSearchParams(window.location.search);
            const sharedDataParam = urlParams.get('data');

            if (sharedDataParam) {
                try {
                    const decodedData = JSON.parse(atob(sharedDataParam));
                    if (decodedData.prefixes && decodedData.roots && decodedData.suffixes) {
                        decodedData.roots = parseRootsData(decodedData.roots);
                        decodedData.prefixes = decodedData.prefixes.sort();
                        decodedData.suffixes = decodedData.suffixes.sort();
                        availableData = decodedData;
                        console.log("Loaded word lists from URL data parameter.");
                    } else {
                        console.warn("Invalid data structure in URL parameter. Falling back to initial data.");
                        availableData = JSON.parse(JSON.stringify(initialAvailableData));
                    }
                } catch (e) {
                    console.error("Error parsing data from URL parameter. Falling back to initial data.", e);
                    availableData = JSON.parse(JSON.stringify(initialAvailableData));
                }
            } else {
                availableData = JSON.parse(JSON.stringify(initialAvailableData));
                console.log("No data parameter found in URL. Using initial word lists.");
            }

            if (urlParams.get('shared') === 'true') {
                if (uploadSectionsContainer) {
                    uploadSectionsContainer.style.display = 'none';
                    console.log("Upload sections hidden for shared link.");
                }
            }

            createOrUpdateInsertionIndicator();
            renderAvailableTiles();
            renderCombinedTiles();
            console.log("Game initialized.");
        });
    </script>
</body>
</html>
